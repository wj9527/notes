----------------------------
锁							|
----------------------------
	# 类型区分
		* 共享锁(读锁 / S 锁)
		* 排它锁(写锁 / X 锁)

		* 意向共享锁
		* 意向排他(互斥)锁

		* 悲观锁
		* 
	
	# 锁的粒度
		
	# 锁的算法
	
	# MYSQL 的 Read Committed, 其实是可以解决幻读的问题
		+---------------------------+-------------------------------------------+
		|  SESSION1					|  SESSION2									|
		+-----------------------------------------------------------------------+
		|start transaction;			|	start transaction;						|
		+-----------------------------------------------------------------------+
		|							|	insert into `user` values(2, 0, 0);		|
		+-----------------------------------------------------------------------+
		|							|	commit;									|
		+-----------------------------------------------------------------------+
		|select * from `user`;		|											|
		+-----------------------------------------------------------------------+
		|commit;					|											|
		+-----------------------------------------------------------------------+

		* SESSION1 的select语句, 不能检索到session2的新插入的记录
		* 如果SESSION2 执行删除提交, 那么SESSION1 未提交之前还是可以读取到这条已经被删除的记录


	# MYSQL 的 Read Committed, 不一定可以彻底解决幻读的问题
		* 数据信息
			+----+---------+---------+
			| id | balance | version |
			+----+---------+---------+
			|  1 |       0 |       1 |
			|  2 |       0 |       1 |
			+----+---------+---------+
		
		* 检索
			+-------------------------------------------------------+-------------------------------------------+
			|SESSION1												|SESSION2									|
			+-------------------------------------------------------+-------------------------------------------+
			|start transaction;										|start transaction;							|
			+-------------------------------------------------------+-------------------------------------------+
			|														|insert into `user` values(3, 0, 2);		|
			+-------------------------------------------------------+-------------------------------------------+
			|														|commit;									|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|update `user` set `balance` = 1 where `version` = 2;	|											|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|commit;												|											|
			+-------------------------------------------------------+-------------------------------------------+

			* SESSION1 第一次检索, 检索不到SESSION2新插入的记录, 防止了幻读
				Empty set (0.00 sec)

			* 但是SESSION1 尝试去对 SESSION2 新插入的记录执行 UPDATE, 可以修改成功
			* 修改成功后, 再次执行 SELECT, 可以检索出SESSION2新插入的记录
				+----+---------+---------+
				| id | balance | version |
				+----+---------+---------+
				|  3 |       1 |       2 |
				+----+---------+---------+
			
			* 原因
				- 在REPEATABLE READ隔离级别下, T1第一次执行普通的SELECT语句时生成了一个ReadView, 之后T2向hero表中新插入了一条记录便提交了
				- ReadView并不能阻止T1执行UPDATE或者DELETE语句来对改动这个新插入的记录, 因为T2已经提交, 所以改动该记录并不会造成阻塞
				- 但是这样一来这条新记录的 trx_id 隐藏列就变成了T1的事务id, 之后T1中再使用普通的SELECT语句去查询这条记录时就可以看到这条记录了
				- 也就把这条记录返回给客户端了, 因为这个特殊现象的存在, 也可以认为InnoDB中的MVCC并不能完完全全的禁止幻读


			
			
			
					


		
		
