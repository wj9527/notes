--------------------------------
shell							|
--------------------------------
	# 第一行指定运行的 bash
		#!/bin/bash
	
	# 查看系统的所有 shell处理器: cat /etc/shells
		/bin/sh
		/bin/bash
		/sbin/nologin
		/usr/bin/sh
		/usr/bin/bash
		/usr/sbin/nologin
		/bin/tcsh
		/bin/csh
	
	# 查看系统使用的shell
		echo $SHELL
	
	# 运行方式
		* 直接运行(需要设置可执行权限:chdmo 775)
			./hello.sh

		* 以指定的shell运行脚本
		* 这种方式运行的脚本,第一行指定的解释器信息没用
			/bin/bash hello.sh
	
	# '#'开头的行就是注释,会被解释器忽略
	
	# 多行注释
		:<<EOF
			注释内容...
			注释内容...
			注释内容...
		EOF
		
		* EOF 也可以换做其他符号

		:<<'
			注释内容...
			注释内容...
			注释内容...
		'

		:<<!
			注释内容...
			注释内容...
			注释内容...
		!

	
--------------------------------
shell - 变量					|
--------------------------------
	# 定义规则
		* 变量名和等号之间不能有空格
		* 命名只能使用英文字母,数字和下划线,首个字符不能以数字开头
		* 中间不能有空格,可以使用下划线(_)
		* 不能使用标点符号
		*  不能使用bash里的关键字(可用help命令查看保留关键字)
	
	# 使用(读取)变量,使用 $ 符号
		name="KevinBlandy"
		echo $name
		echo${name}

		* 变量名外面的花括号是可选的,加不加都行
		* 加花括号是为了帮助解释器识别变量的边界,比如变量在字符串里面
			for skill in Java PHP Python; do
				echo "I am good at ${skill}"
			done
		* 变量没有使用$符,会被当做字符串处理
	
	# 变量可以被多次定义(修改)
		name="KevinBlandy"
		name="Litch"
	
	# 使用 readonly 关键字设置只读变量
		name="KevinBlandy"
		readonly name

		* 尝试修改name变量,会抛出异常
	
	# 使用 unset 删除变量
		name="KevinBlandy"
		unset name
	
	# 变量的作用域类型

		* 局部变量 局部变量在脚本或命令中定义,仅在当前shell实例中有效,其他shell启动的程序不能访问局部变量

		* 环境变量 所有的程序,包括shell启动的程序,都能访问环境变量,有些程序需要环境变量来保证其正常运行
		* 必要的时候shell脚本也可以定义环境变量

		* shell变量 shell变量是由shell程序设置的特殊变量
		* shell变量中有一部分是环境变量,有一部分是局部变量,这些变量保证了shell的正常运行
	

	# 后引号运算
		* 把``里面的内容当作命令去解析,返回执行的结果

		sum=`expr 15 + 15`
		echo $sum# -> 30
		
		* 也可以使用 $() 来代替 ``
			sum=$(expr 15 + 15)
			echo $sum# -> 30

	

--------------------------------
重定向输入输出					|
--------------------------------
	# 重定向输出
		cmd > target

		* 会把cmd命令执行的结果写入到target文件(文件不存在会创建)
		* 如果文件已经存在,那么会直接覆盖

	# 仅仅追加,不覆盖,使用 >>
		cmd >> target

	# 输入重定向
		cmd < target

		* 把target里面的数据重定向给cmd命令


	# 内联重定向
		..


--------------------------------
管道							|
--------------------------------
	# 把一个命令的输出,当作另一个命令的输入
		cmd1 | cmd2
		
		* 把cd1的输出结果写入到cmd2
		* 这俩命令并不是先后执行的,而是同时执行的,系统会在内部把他俩连接起来
	
	# 常用在more上
		 rpm -qa | sort | more

		 * 可以把很长的数据通过管道给more
		 * 从而仅仅显示一小段儿,可以通过翻页的形式来读取


--------------------------------
数学运算 - expr					|
--------------------------------
	# expr 执行乘法,乘号要转义
		expr 4 * 4	# expr: syntax error
		expr 4 \* 4 #16

		* 因为*号是特殊符号,需要使用 \ 来转义
	
	# 也可以使用方括号执行数学表达式
		val=$[5 + 5]
		echo $val # 10
		echo $[5 + ${val}] #15
	
		*  这种方式使用 *  来执行乘法操作,不用转义
	
	# bash中的数学运算,仅仅支持整数的运算
		v1=100
		v2=45
		echo $[v1 / v2]	# 2

		* 运算结果仅仅保留整数
		* 另一个shell(zshell)可以实现浮点数的运算
	
	# 浮点数的解决方案
		...


--------------------------------
脚本退出						|
--------------------------------
	# 查看退出的状态码
		echo $?
	
		* 该命令会返回最后一次shell命令执行的状态码
	
	# 状态码
		0		命令成功结束
		1		一般性未知错误
		2		不适合shell命令
		126		命令不可执行
		127			没找到命令
		128		无效的退出参数
		128+x	与Linux信号x相关的严重错误
		130		通过ctrl + c终止命令
		255		正常范围之外的退出状态码
	
	# 使用exit终止脚本
		* 默认情况下,shell脚本会以脚本中最后一个命令的退出状态码退出
		* 可以修改这种默认行为,返回自己的状态码

		exit val	# val就是状态码之一
		
		* 该值也可以是一个变量
			exit $val
		
		* 该值最大只能是255,系统会对该值进行模运算
		
			
	


